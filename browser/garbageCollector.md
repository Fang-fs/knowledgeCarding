### 垃圾收集原理：

#### javascript中的垃圾收集

-程序的运行需要内存，只要程序要求，操作系统就必须提供内存

- javascript使用自动内存管理，这被成为“垃圾回收机制”（garbage collector）

- 优点 可以简化开发、节省代码

- 缺点是无法完整的掌握内存的分配与回收的具体过程

#### NodeJS 中的内存管理

- 网页端的内存泄漏

- 对于持续运行的服务进程Node服务端程序，必须及时释放不再用到的内存。否则，内存越来越高，轻则影响系统性能，重则导致进程崩溃

- 如果不再用到的内存没有及时释放，就叫做内存泄漏

#### V8 内存管理

v8 内存限制 

在64位操作系统中可以使用1.4G内存

在32位操作系统中可以使用0.7G

#### V8 内存管理

- js对象都是通过v8来分配内存的
- process.memeoryUsage 返回一个对象，包含了Node

### V8垃圾回收分为新生代和老生代

- 年龄小的是新生代，由From区域和To区域两个区域组成

-- 在64位系统里，新生代内存是32M,From和to各占用16M

-- 在32位系统里，新生代内存是16M,from区域和to区域各占用8m

- 年龄大的是老生代，默认情况为：

-- 64位系统下的老生代内存是1400M

-- 32位系统下老生代内存是700M



新生代垃圾回收和老生代垃圾回收的机制是不一样的

新生代是检查引用次数

老生代是标记清除 标记整理

老生代空间大，大部分都是活着的对象，gc耗时比较长

在GC期间无法相应，STOP-THE-WORLD

V8有一个优化方案，增量处理，把一个大暂停换成多少个小暂停INCREMENT-GC

标记清除

- 标记活着的对象，随后清除在标记阶段没有标记的对象，只清理死亡对象

- 问题在于清除后会出现内存不连续的情况，这种内存碎片会对后续的内存分配产生影响

- 如果要分配一个大对象，碎片空间无法分配

先标记后清理 会造成内存碎片

标记整理

- 标记死亡后会对对象进行整理，活着的对象向左移动，移动完成后直接清理掉边界外的内存

方式内存不浪费 但是时间比较慢

会先用标记清除 再用 标记整理 处理的频率不一样

*** Mark-Compact 需要移动对象，执行速度不快，V8主要用Mark-Sweep,空间不足以对从新生代升级过来的对象时才会用Mark-Compact




